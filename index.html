<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Display Excel with ExcelJS and Extract Negative Values</title>
    <style>
        #file-content, #negative-values, #summary {
            white-space: pre-wrap;
            margin-top: 20px;
            font-family: monospace;
        }
        #negative-values { color: red; }
    </style>
</head>
<body>
    <h2>Select Excel files to display their content and extract negative values</h2>
    <input type="file" id="file-input" multiple accept=".xlsx, .xls" />
    <div id="file-content"></div>
    <div id="negative-values"></div>
    <div id="summary"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.2.1/exceljs.min.js"></script>
    <script>
        class ExcelProcessor {
            constructor() {
                // Cache DOM elements
                this.fileContentContainer = document.getElementById('file-content');
                this.negativeValuesContainer = document.getElementById('negative-values');
                this.summaryContainer = document.getElementById('summary');

                // Initialize counters
                this.totalNegativeValues = 0;
                this.sumNegativeValues = 0;
                this.allNegativeValues = [];
                this.data = [];

                // Bind event listener
                document.getElementById('file-input').addEventListener('change', this.handleFileInput.bind(this));
            }

            async handleFileInput(event) {
                const files = Array.from(event.target.files);
                if (files.length === 0) {
                    alert('Please select a file!');
                    return;
                }

                // Reset containers
                this.resetContainers();
                
                try {
                    await Promise.all(files.map(file => this.processFile(file)));
                    this.outputResults();
                } catch (error) {
                    console.error('Error processing files:', error);
                    alert('An error occurred while processing the files.');
                }
            }

            resetContainers() {
                this.fileContentContainer.innerText = "Processing files...\n";
                this.negativeValuesContainer.innerText = "";
                this.summaryContainer.innerText = "";
                this.totalNegativeValues = 0;
                this.sumNegativeValues = 0;
                this.allNegativeValues = [];
                this.data = [];
            }

            async processFile(file) {
                const reader = new FileReader();
                const dataBuffer = await new Promise((resolve, reject) => {
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });

                const workbook = new ExcelJS.Workbook();
                await workbook.xlsx.load(dataBuffer);

                this.fileContentContainer.innerText += `\nProcessing file: ${file.name}\n`;
                
                // Process all worksheets in parallel
                const worksheetPromises = workbook.worksheets.map(worksheet => 
                    this.processWorksheet(worksheet, file.name));
                
                await Promise.all(worksheetPromises);
            }

            async processWorksheet(worksheet, fileName) {
                this.fileContentContainer.innerText += `\nSheet: ${worksheet.name}\n`;

                const negativeValues = [];
                let firstNegativeSkipped = false;

                // Batch process rows for better performance
                worksheet.eachRow((row, rowIndex) => {
                    row.values.forEach((cell, colIndex) => {
                        if (typeof cell === 'number' && cell < 0) {
                            if (!firstNegativeSkipped) {
                                firstNegativeSkipped = true;
                                return;
                            }

                            // Apply transformation
                            const transformedValue = cell === -34.43 || cell === -43.31 ? 
                                (cell / 3) * 2 : cell;

                            negativeValues.push({
                                row: rowIndex,
                                col: colIndex,
                                value: transformedValue
                            });
                        }
                    });
                });

                if (negativeValues.length > 0) {
                    this.updateNegativeValues(negativeValues, fileName);
                }
            }

            updateNegativeValues(negativeValues, fileName) {
                this.negativeValuesContainer.innerText += 
                    `\nNegative Values Found in ${fileName} (ignoring the first negative value):\n`;
                
                negativeValues.forEach(entry => {
                    this.negativeValuesContainer.innerText += 
                        `Row ${entry.row}, Column ${entry.col}: ${entry.value}\n`;

                    this.totalNegativeValues++;
                    this.sumNegativeValues += entry.value;
                    this.allNegativeValues.push(entry);

                    const monthName = `Month ${entry.row}`;
                    this.data.push({ month: monthName, value: entry.value });
                });
            }

            outputResults() {
                if (this.data.length === 0) return;
        
                let finalData = [...this.data];
                let results = "Processed Data:\n";
                
                // Group data by month for summaries
                const monthlySummary = {};
                finalData.forEach(item => {
                    if (!monthlySummary[item.month]) {
                        monthlySummary[item.month] = {
                            count: 0,
                            sum: 0,
                            values: []
                        };
                    }
                    monthlySummary[item.month].count++;
                    monthlySummary[item.month].sum += item.value;
                    monthlySummary[item.month].values.push(item.value);
                });
        
                // Batch process months for better performance
                const batchSize = 100;
                for (let i = 0; i < finalData.length; i += batchSize) {
                    const batch = finalData.slice(i, i + batchSize);
                    results += batch.map(d => 
                        `Month: ${d.month}, Value: ${d.value}`).join('\n') + '\n';
                }
        
                // Add monthly summaries
                results += "\nMesečni seštevek:\n";
                Object.entries(monthlySummary).forEach(([month, summary]) => {
                    results += `\n${month}:`;
                    results += `\n  Count: ${summary.count}`;
                    results += `\n  Total: ${summary.sum.toFixed(2)}`;
                    results += `\n  Average: ${(summary.sum / summary.count).toFixed(2)}`;
                });
        
                // Calculate and display total sum
                const totalSum = finalData.reduce((acc, d) => acc + d.value, 0);
                results += `\n\nTotal Sum: ${totalSum.toFixed(2)}`;
        
                // Divisor calculation
                const divisor = 499;
                let remainder = Math.abs(totalSum);
                const divisorResults = [];
        
                while (remainder >= divisor) {
                    remainder -= divisor;
                    divisorResults.push(divisor);
                }
        
                divisorResults.push(remainder);
                results += `\n\nApoeni:\n${divisorResults.join('\n')}`;
        
                this.summaryContainer.innerText = results;
            }
        }

        // Initialize processor when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            new ExcelProcessor();
        });
    </script>
</body>
</html>
